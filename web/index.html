<!doctype html>
<html lang="en">
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>subtwitter</title>
        <style>
            * {
                margin: 0;
                padding: 0;
            }

            html, body {
                height: 95%;
            }

            h1 {
                margin-left: 5px;
            }

            .container {
                display: inline-flex;
                flex-direction: row;
                flex-wrap: no-wrap;
                width: 100%;
                height: 100%;
            }

            #timeline, #feed, #mentions {
                flex-grow: 1;
                flex-shrink: 0;
                flex-basis: 33%;
                border: 2px solid black;
                overflow-y: scroll;
            }

            .tweet {
                flex-direction: row;
                flex-wrap: no-wrap;
                align-items: flex-start;
                position: relative;
                display: inline-flex;
                padding: 0.5em;
                border: 1px solid #111;
                width: 95%;
                animation: fadein 1s;
            }

            .tweet-av {
                flex-grow: 0;
                flex-shrink: 0;
                flex-basis: 50px;
            }

            .tweet-av > img {
                width: 50px;
                height: 50px;
            }

            .tweet-txt {
                margin-left: 1em;
                flex-grow: 1;
                flex-shrink: 0;
                flex-basis: content;
                word-wrap: break-word;
                width: 0%;
            }

            .tweet-head {
                font-size: 0.8em;
            }

            .tweet-head > a {
                font-style: italic;
            }

            .tweet-bot {
                text-align: right;
                font-size: 0.7em;
            }

            .tweet-bot > img {
                height: 2em;
                width: auto;
                margin-left: 3px;
                margin-bottom: -7px;
                cursor: pointer;
            }

            .context-img {
                height: 1em;
                width: auto;
            }

            @keyframes fadein {
                from { opacity: 0; }
                to   { opacity: 1; }
            }
        </style>   
        <script type="text/javascript" src="js/extern/socket.io.min.js"></script>
        <script type="text/javascript" src="js/extern/lodash.min.js"></script>
    </head>
    <body>
        <h1>subtwitter</h1>

        <div class="container">
            <div id="timeline"></div>
            <div id="feed"></div>
            <div id="mentions"></div>
        </div>

        <script>
            "use strict";

            const LIM = 500;
            const TZ = (new Date()).getTimezoneOffset() * 60 * 1000;

            const socket = io.connect("http://localhost:7001");

            //this design the same tweet could be copied in three places
            //this... is probably desirable
            //lets us work indiv but also ubiquitous forAll-type helpers
            //if proves unwieldly just maintain one buffer
            //and give each of these an array of pointers
            function Stream(name, active, viewing) {
                this.el = viewing ? document.getElementById(name) : null;
                this.buffer = [];
                this.active = active;
                this.viewing = viewing;
            }

            function Streams() {
                this.timeline = new Stream("timeline", true, true);
                this.feed = new Stream("feed", true, true);
                this.mentions = new Stream("mentions", true, true);
                this.dms = new Stream("dms", true, false);
            }

            Streams.prototype = {
                viewing: function() {
                    return _(this)
                        .keys()
                        .filter(key => this[key].viewing)
                        .value();
                },
                buffers: function() {
                    return _.map(this, stream => stream.buffer);
                },
                truncate: function(stream) {
                    let buffers = stream ? [this[stream].buffer] : this.buffers();
                    _.each(buffers, buffer => buffer.length > LIM && buffer.shift());
                },
                flush: function(stream) {
                    let buffers = stream ? [this[stream].buffer] : streams.buffers();
                    _.each(buffers, buffer => buffer = []);
                }
            };

            let streams = new Streams();

            const timestamp = tweet =>
                new Date(parseInt(tweet.timestamp_ms, 10) - TZ).toISOString().replace("T"," ").slice(0,-5);

            //FIXME disable rts for self/protected
            const buttons = (tweet, stream) =>
                _.map(["retweet", "like", "reply"], action => `
                    <img id="${stream}-${action}-${tweet.id_str}"
                    onclick="actions('${action}','${tweet.id_str}')"
                    src="img/${action}.png">`)
                    .join(" ");

            const contexts = {
                retweet: tweet =>
                    `<img class="context-img" src="img/retweet-on.png"> ${tweet.retweeter}<br/>`,
                reply: tweet =>
                    `<img class="context-img" src="img/reply.png"> ${tweet.in_reply_to_screen_name}<br/>`,
                icon: tweet => {
                    if(tweet.user.protected)
                        return '<img class="context-img" src="img/protected.png">';
                    else if(tweet.user.verified)
                        return '<img class="context-img" src="img/verified.png">';
                    else
                        return "";
                }
            };

            const actions = (action, id_str) => {
                if(action == "reply") {
                    console.log("not implemented!");
                    return;
                }

                //FIXME this is silly, clean up naming a bit
                const base = action.replace(/^un/, "");
                const inverse = action == base ? "un" + base : base;
                const img = action == base ? base + "-on" : base;

                console.log(action, base, inverse, img);

                socket.emit(action, id_str);

                _.each(streams.viewing(), stream => {
                    let el = document.getElementById(`${stream}-${base}-${id_str}`);
                    if(el) {
                        el.src = `img/${img}.png`;
                        el.setAttribute("onClick", `actions('${inverse}','${id_str}')`);
                        console.log(`actions('${inverse}','${id_str}')`);
                    }
                });
            };

            const buildTweet = (tweet, stream) => {
                const el = `
                <div id="${stream}-${tweet.id_str}" class="tweet">
                    <div class="tweet-av"><img src="${tweet.user.profile_image_url}"></div>
                    <div class="tweet-txt">
                        <div class="tweet-head">
                            ${tweet.retweeter ? contexts.retweet(tweet) : tweet.in_reply_to_screen_name ? contexts.reply(tweet) : ""}
                            <strong>${tweet.user.name}</strong> @${tweet.user.screen_name} ${contexts.icon(tweet)}<br/>
                            ${timestamp(tweet)} via ${tweet.source}
                        </div>
                        ${tweet.text}<br/>
                        <div class="tweet-bot"> ${buttons(tweet, stream)}</div>
                    </div>
                </div>`;

                let div = document.createElement("div");
                div.innerHTML = el;

                return div;
            };

            socket.on("join", msg => {
                console.log(msg);
            });

            socket.on("log", msg => {
                console.log(msg);
            });

            socket.on("timeline", tweet => {
                //console.log(tweet);
                streams.truncate();

                streams.timeline.buffer.push(tweet);
                timeline.insertBefore(buildTweet(tweet, "timeline"), timeline.firstChild);
            });

            socket.on("feed", tweet => {
                //console.log(tweet);
                streams.truncate();

                streams.feed.buffer.push(tweet);
                feed.insertBefore(buildTweet(tweet, "feed"), feed.firstChild);
            });

            socket.on("mentions", tweet => {
                //console.log(tweet);
                streams.truncate();

                streams.mentions.buffer.push(tweet);
                mentions.insertBefore(buildTweet(tweet, "mentions"), mentions.firstChild);
            });
        </script>
    </body>
</html>
